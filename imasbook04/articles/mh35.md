# コンベンションセンターをサーバレスで実現する

コンベンションセンター、まあ要するにアイドル別掲示板である。これをサーバレスでやってみたい、というわけである。実現するに当たっては、いろいろなところの助けを借りつつ、こんな感じの構成にした。

- Amazon AWSを用いる
- フロント側はVue.js+TypeScriptを用いる
- バックエンドはデータベースとしてDynamoDBを用いて、各種エンドポイントはLambda+API Gatewayを用いる
- Lambdaの言語はPython3を用いる
- 認証基盤はCognitoを用いて、Google認証に対応する

なお、将来的に同じ構成を用いる可能性があり得たため(常設するか、それとも年度ごとに廃棄して作り直すか未定だったこともあり)、今回はCloudFormationによるバックエンド側のデプロイを採用することにした。フロントエンド側はS3+CloudFrontの構成なので、これはデプロイ機能は後回しにする予定である。

## CloudFormationとは

CloudFormationとは、テンプレートを用いたリソースのモデル化とプロビジョニングと公式では紹介されている。まあ要するにテンプレートを使って自動でリソースを作成・廃棄するための仕組みである。
そのテンプレートはJSONかYAMLを作って記述をする。Web上のコンソールではオンラインでGUIを使って記述をすることもできるのだが、限度があるため、YAMLで実際のテンプレートを記述することにする。

## テンプレートの書式

テンプレートは、以下の9つの要素からなるマップである。

- AWSTemplateFormatVersion テンプレートのバージョンを書く。文字列型であり、現在有効な値は2010-09-09のみである。省略した場合、現在の最新版を指定したものとみなす
- Description テンプレートのコメントを書く。文字列型であり、AWSTemplateFormatVersionより後に記述する必要がある。また、0バイト以上1024バイト以下である必要がある
- Metadata メタデータを書く。任意のマップを入れることができるが、一部のキーは特別な意味を持つ
- Parameters テンプレートに渡すパラメータを書く。ここで指定したパラメータを、プロビジョニング時に指定することができる。マップで指定する。マップのキーがパラメータ名である。マップの値はそのパラメータの設定であり、マップである。以下の要素がある
    - Type 唯一必須の要素で、このパラメータの型を指定する。許容される値はString・Number・List&lt;String&gt;・List&lt;Number&gt;・CommaDelimitedList、もしくはAWS固有のパラメータ型・SSMパラメータタイプのいずれかである
    - Description このパラメータの説明である。4000文字以下の文字列である必要がある
    - Default このパラメータのデフォルト値である
    - NoEcho このパラメータを出力で表示するときにマスキングするか。論理値型で、trueを指定するとマスキングされる
    - AllowedValues 許容される値のリスト。シーケンス型である必要がある
    - AllowedPattern 許容される値の正規表現。文字列型である必要がある
    - MinLength 最小文字数。数値型である必要がある
    - MaxLength 最大文字数。数値型である必要がある
    - MinValue 最小値。数値型である必要がある
    - MaxValue 最大値。数値型である必要がある
    - ConstraintDescription 制約違反時に出てくるメッセージ。文字列型である必要がある
- Mappings キーと名前付きの一連の値の関連付けを書く。マップ型である必要があり、各要素のキーがその関連付けの名前、値が一連の値である。一連の値はマップ型である。なお、キーには英数字のみを指定できる
- Conditions 条件定義を書く。この条件はリソース定義のときに参照可能で、その条件を満たしたときにだけリソースを作成するように書くことができる。マップで記述する。キーが条件式の名前、値がその条件の式である
- Transform CloudFormationが処理するマクロの指定。Lambdaを使うときにSAMのバージョンを指定するためによく使う
- Resources 唯一必須のパラメータ。どのリソースをプロビジョニングするか指定する。マップであり、キーにリソースのこのテンプレート上での名前(論理ID)、値にそのリソース設定のマップを書く。そのマップには以下の2つの要素がある
    - Type そのリソースのタイプ。例えばAWS::EC2::InstanceならEC2インスタンスである
    - Properties そのリソースの設定。設定項目はTypeごとに異なる
- Outputs 他のスタック(プロビジョニングの内容)にインポートしたり、応答として返したり、CloudFormationコンソールで出力する値の宣言。マップであり、キーにその出力の名前(論理ID)、値にその出力の定義のマップを記述する。そのマップの要素は以下の通り
    - Description 説明文字列
    - Value 必須で、出力されるプロパティの値
    - Export クロススタック参照で、参照元へエクスポートする名前。Nameというキーで、値にエクスポートする値を指定する

結局、各リソースごとに指定するプロパティがわからないと何もできないが、リファレンスを参照すればわかるので、AWSのドキュメントを参照すること。

## 具体的な記述例

今回用いるリソースは以下の通りである。

- DynamoDB
- Cognito
- Lambda
- API Gateway

それぞれの記述は以下の通りである。

### DynamoDB

オートスケールがない場合のDynamoDBの記述は以下の通りである。

```yaml
Resources:
    dynamoTable:
        Type: AWS::DynamoDB::Table
        Properties:
            AttributeDefinitions:
                -
                    AttributeName: Id
                    AttributeType: 'S'
                -
                    AttributeName: Timestamp
                    AttributeType: 'N'
                -
                    AttributeName: Type
                    AttributeType: 'S'
            KeySchema:
                -
                    AttributeName: Id
                    KeyType: HASH
                -
                    AttributeName: Timestamp
                    KeyType: RANGE
            GlobalSecondaryIndexes:
                -
                    IndexName: GSI
                    KeySchema:
                        -
                            AttributeName: Type
                            KeyType: HASH
                        -
                            AttributeName: Timestamp
                            KeyType: RANGE
                    Projection:
                        ProjectionType: ALL
                    ProvisionedThroughput:
                        ReadCapacityUnits: 5
                        WriteCapacityUnits: 5
            ProvisionedThroughput:
                ReadCapacityUnits: 5
                WriteCapacityUnits: 5
```

この指定により、以下のような設定でDynamoDBのテーブルが作成される。設定は以下の通り。

- IdというPartition Key、TimestampというSort Keyを持つ
- Idは文字列型、Timestampは数値型、Typeは文字列型である
- Global Secondary IndexとしてGSIというものが定義されており、それは射影としてすべての属性を持つ。パーティションキーとしてType、ソートキーとしてTimestampを持つ
- 本体のテーブル、GSI、ともにプロビジョニングされているスループットは読み書きともに5ユニットである
    - 1RCUで1項目4KBまでの強力な整合性のある読み込みを1秒に1回実行できる。結果整合性のある読み込みは1回あたり0.5RCU、トランザクション読み込みは1回あたり2RCUである
    - 1WCUで1項目1KBまでの標準の書き込み要求を1秒に1回実行できる。トランザクション書き込みは1回あたり2WCU必要である

この設定ではオートスケールしないため、キャパシティをオーバーするとスロットルする。このため、オートスケールを可能にするための設定を加える。オートスケールするDynamoDBは、以下のような記述になる。

```yaml
Resources:
    dynamoTable:
        Type: AWS::DynamoDB::Table
        Properties:
            AttributeDefinitions:
                -
                    AttributeName: Id
                    AttributeType: 'S'
                -
                    AttributeName: Timestamp
                    AttributeType: 'N'
                -
                    AttributeName: Type
                    AttributeType: 'S'
            KeySchema:
                -
                    AttributeName: Key
                    KeyType: HASH
                -
                    AttributeName: Timestamp
                    KeyType: RANGE
            GlobalSecondaryIndexes:
                -
                    IndexName: GSI
                    KeySchema:
                        -
                            AttributeName: Type
                            KeyType: HASH
                        -
                            AttributeName: Timestamp
                            KeyType: RANGE
                    Projection:
                        ProjectionType: ALL
                    ProvisionedThroughput:
                        ReadCapacityUnits: 5
                        WriteCapacityUnits: 5
            ProvisionedThroughput:
                ReadCapacityUnits: 5
                WriteCapacityUnits: 5
    dynamoTableReadCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:table:ReadCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableWriteCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:table:WriteCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableGSIReadCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
                    - index
                    - GSI
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:index:ReadCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableGSIWriteCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
                    - index
                    - GSI
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:index:WriteCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableScalingRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    -
                        Effect: Allow
                        Principal:
                            Service:
                                - application-autoscaling.amazonaws.com
                        Action: 'sts:AssumeRole'
            Path: '/'
            Policies:
                -
                    PolicyName: 'root'
                    PolicyDocument:
                        Version: '2012-10-17'
                        Statement:
                            -
                                Effect: Allow
                                Action:
                                    - 'dynamodb:DescribeTable'
                                    - 'dynamodb:UpdateTable'
                                    - 'cloudwatch:PutMetricAlarm'
                                    - 'cloudwatch:DescribeAlarms'
                                    - 'cloudwatch:GetMetricStatistics'
                                    - 'cloudwatch:SetAlarmState'
                                    - 'cloudwatch:DeleteAlarms'
                                Resource: '*'
    dynamoTableReadScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableReadScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableReadCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBReadCapacityUtilization
    dynamoTableWriteScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableWriteScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableWriteCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBWriteCapacityUtilization
    dynamoTableGSIReadScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableGSIReadScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableGSIReadCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBReadCapacityUtilization
    dynamoTableGSIWriteScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableGSIWriteScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableGSIWriteCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBWriteCapacityUtilization
```

この指定は、こういうことである

- 先ほどと同じ設定でDynamoDBテーブルを作成する
- Application Auto Scalingのターゲットを4つ作成する。それぞれRCU・WCU・GSIのRCU・GSIのWCUであり、最小値5、最大値400で設定している
- IAMロールを作成する。これは以下のような内容を持つ
    - application-autoscaling.amazonaws.com に権限を委譲する
    - 以下の内容を許可する
        - DynamoDBテーブルの詳細を取得・更新する
        - CloudWatchアラームを作成・更新・名前での検索・状態設定・削除できる
        - CloudWatchメトリックの値を読み取りできる
- Application Auto Scalingのポリシーを4つ作成する。オートスケールのターゲットは先程作成したもので、いずれもキャパシティ使用率70%に到達するとオートスケール、スケールアウトのクールダウンは120秒、スケールインのクールダウンは900秒である

要するに、RCU・WCU・GSIのRCU・GSIのWCUを5以上400以下でオートスケールするようになる、ということである。

### Cognito

ユーザープールを定義する必要があるのだが、その前にユーザープールのIdP設定を書く必要があるらしい。このため、書き方は以下の通りとなる。

```yaml
Parameters:
    GoogleClientId:
        Type: String
        Description: 'Google API client ID'
    GoogleClientSecret:
        Type: String
        NoEcho: true
        Description: 'Google API client secret'
Resources:
    userPoolProvider:
        Type: AWS::Cognito::UserPoolIdentityProvider
        Properties:
            UserPoolId: !Ref userPool
            ProviderName: Google
            ProviderType: Google
            AttributeMapping:
                email: emailAddress
            ProviderDetails:
                client_id: !Ref GoogleClientId
                client_secret: !Ref GoogleClientSecret
                authorize_scopes: email openid
    userPool:
        Type: AWS::Cognito::UserPool
        Properties:
            AdminCreateUserConfig:
                AllowAdminCreateUserOnly: false
            AliasAttributes:
                - email
            Schema:
                -
                    AttributeDataType: String
                    DeveloperOnlyAttribute: false
                    Name: email
                    Mutable: true
                    Required: false
                -
                    AttributeDataType: String
                    DeveloperOnlyAttribute: false
                    Name: role
                    Mutable: true
                    Required: false
    userPoolClient:
        Type: AWS::Cognito::UserPoolClient
        Properties:
            ClientName: 'ConventionCenterAuth'
            ReadAttributes:
                - email
                - 'custom:role'
            GenerateSecret: false
            SupportedIdentityProviders:
                - COGNITO
                - Google
            UserPoolId: !Ref userPool
            WriteAttributes:
                - email
                - 'custom:role'
```

この指定は、こういうことである。

- ユーザープールを以下の設定で作成する
    - 属性はemail(文字列)とrole(文字列)の2つ
    - email属性でのログインを許可
    - サインアップは誰でも可能
- そのユーザープールに対してログイン可能なIdPを以下の設定で作成する
    - プロバイダ名はGoogle
    - Googleを使ってサインインする
    - 取得した属性emailAddressをemail属性にマッピング
    - emailとopenidをスコープとしてOAuthリクエストを行う。その際のクライアントIDとクライアント秘密鍵はパラメータで指定する。クライアント秘密鍵は表示時にマスキングされる
- そのユーザープールのアプリクライアントを以下の設定で作成する
    - emailとroleを読み書き可能
    - Cognito自身の認証とGoogle認証をサポート

ドメインや証明書の設定はしていないため、必要に応じてマネジメントコンソールから設定すること。

### S3+CloudFront

S3+CloudFrontの設定は以下の通りである。ドメインの設定はあとから行うのでここでは行わない。
基本的な説明は https://dev.classmethod.jp/cloud/aws/s3-cloudfront-with-oai-by-cloudformation/ の通りである。

```yaml
Resources:
    contentBucket:
        Type: AWS::S3::Bucket
        # 削除時にバケットを維持する
        # これを指定しないとスタック削除時に詰む
        DeletionPolicy: Retain
    bucketCFAccessIdConf:
        Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
        Properties:
            CloudFrontOriginAccessIdentityConfig:
                Comment: !Ref AWS::StackName
    contentBucketPolicy:
        Type: AWS::S3::BucketPolicy
        Properties:
            Bucket: !Ref contentBucket
            PolicyDocument:
                Statement:
                    -
                        Action: s3:GetObject
                        Effect: Allow
                        Resource: !Join
                            - ':'
                            -   - 'arn:aws:s3::'
                                - !Join
                                    - /
                                    -   - !Ref contentBucket
                                        - '*'
                        Principal:
                            AWS: !Join
                                - /
                                -   - arn:aws:iam::cloudfront:user
                                    - !Join
                                        - ' '
                                        -   - 'CloudFront Origin Access Identity'
                                            - !Ref bucketCFAccessIdConf
    contentDistribution:
        Type: AWS::CloudFront::Distribution
        Properties:
            DistributionConfig:
                Origins:
                    -
                        Id: S3Origin
                        DomainName: !GetAtt contentBucket.DomainName
                        S3OriginConfig:
                            OriginAccessIdentity: !Join
                                - /
                                -   - origin-access-identity
                                    - cloudfront
                                    - !Ref bucketCFAccessIdConf
                Enabled: true
                DefaultRootObject: index.html
                Comment: !Join
                    - ' '
                    -   - !Ref AWS::StackName
                        - distribution
                DefaultCacheBehavior:
                    TargetOriginId: S3Origin
                    ForwardedValues:
                        QueryString: false
                    ViewerProtocolPolicy: redirect-to-https
```

これにより、空のバケットが作成され、CloudFront配信が行われる。独自ドメインの設定とSSL証明書の設定は後ほどマネジメントコンソールなどから行うこと。

### Lambda

基本的なLambdaの記述は以下の通りである。なお、DynamoDBは先程の設定どおりdynamoTableというキーで作ったものとする。

```yaml
Transform: 'AWS::Serverless-2016-10-31'
Resources:
    dynamoTable:
        Type: AWS::DynamoDB::Table
        # 以下略
    accessDynamoTablePolicy:
        Type: AWS::IAM::ManagedPolicy
        Properties:
            Description: Access to app DynamoDB table
            Path: /
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    -
                        Effect: Allow
                        Action:
                            - 'dynamodb:BatchGetItem'
                            - 'dynamodb:BatchWriteItem'
                            - 'dynamodb:ConditionCheckItem'
                            - 'dynamodb:PutItem'
                            - 'dynamodb:DescribeTable'
                            - 'dynamodb:DeleteItem'
                            - 'dynamodb:GetItem'
                            - 'dynamodb:Scan'
                            - 'dynamodb:Query'
                            - 'dynamodb:UpdateItem'
                        Resource:
                             - !Join
                                - ':'
                                -   - 'arn:aws:dynamodb'
                                    - !Ref AWS::Region
                                    - !Ref AWS::AccountId
                                    - !Join
                                        - '/'
                                        -   - table
                                            - !Ref dynamoTable
                            - !Join
                                - ':'
                                -   - 'arn:aws:dynamodb'
                                    - !Ref AWS::Region
                                    - !Ref AWS::AccountId
                                    - !Join
                                        - '/'
                                        -   - table
                                            - !Ref dynamoTable
                                            - index
                                            - GSI
    getIdolsLambda:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri:
                Bucket: src-bucket
                Key: initLambda.zip
            Handler: lambda_function.lambda_handler
            Runtime: python3.7
            Timeout: 10
            MemorySize: 128
            Policies:
                - !Ref accessDynamoTablePolicy
            Environment:
                Variables:
                    TABLE_NAME: !Ref dynamoTable
    getIdolsLambdaLog:
        Type: AWS::Logs::LogGroup
        Properties:
            LogGroupName: !Join
                - '/'
                -   - '/aws/lambda'
                    - !Ref getIdolsLambda
            RetentionInDays: 30
```

これにより、以下のような設定でリソースが作成される。

- dynamoTableで作成したDynamoDBテーブル及びそのGSIへの読み書き削除の権限が許可されるポリシー
- 基本的な権限と上記権限が付与されたLambda関数
- 上記関数がアクセスするLambdaロググループ

なお、事前にS3のsrc\_bucketにinitLambda.zipというデプロイパッケージをアップロードすることを忘れないこと。

### API Gateway

API Gatewayの記述は以下の通りである。なお、各種リソースはこれまで書いてきたものの通りとする。

```yaml
Resources:
    userPool:
        Type: AWS::Cognito::UserPool
        # 以下略
    getIdolsLambda:
        Type: AWS::Serverless::Function
        # 以下略
    createIdolLambda:
        Type: AWS::Serverless::Function
        # 以下略。だいたいgetIdolsLambdaと同じ
    apiGateway:
        Type: AWS::ApiGateway::RestApi
        Properties:
            Description: 'Convention center REST API'
            Name: 'Convention Center API'
            EndpointConfiguration:
                Types:
                    - REGIONAL
    apiGatewayAuthorizer:
        Type: AWS::ApiGateway::Authorizer
        Properties:
            ProviderARNs:
                - !GetAtt userPool.Arn
            AuthorizerResultTtlInSeconds: 300
            Type: COGNITO_USER_POOLS
            IdentitySource: method.request.header.Authorization
            Name: RestApiAuthorizer
            RestApiId: !Ref apiGateway
    idolsResource:
        Type: AWS::ApiGateway::Resource
        Properties:
            RestApiId: !Ref apiGateway
            ParentId: !GetAtt apiGateway.RootResourceId
            PathPart: idols
    optionsIdolsMethod:
        # これは https://stackoverflow.com/questions/40292888/ を参考に
        Type: AWS::ApiGateway::Method
        Properties:
            AuthorizationType: NONE
            RestApiId: !Ref apiGateway
            ResourceId: !Ref idolsResource
            HttpMethod: OPTIONS
            Integration:
                IntegrationResponses:
                    -
                        StatusCode: 200
                        ResponseParameters:
                            method.response.header.Access-Control-Allow-Headers:
                                # 実際は文字列内は改行しない
                                "'Content-Type,X-Amz-Date,Authorization,
                                X-Api-Key,X-Amz-Security-Token'"
                            method.response.header.Access-Control-Allow-Methods:
                                "'GET,POST,OPTIONS'"
                            method.response.header.Access-Control-Allow-Origin:
                                "'*'"
                        ResponseTemplates:
                            application/json: ''
                PassthroughBehavior: WHEN_NO_MATCH
                RequestTemplates:
                    application/json: '{"statusCode": 200}'
                Type: MOCK
            MethodResponses:
                -
                    StatusCode: 200
                    ResponseModels:
                        application/json: 'Empty'
                    ResponseParameters:
                        method.response.header.Access-Control-Allow-Headers:
                            false
                        method.response.header.Access-Control-Allow-Methods:
                            false
                        method.response.header.Access-Control-Allow-Origin:
                            false
    getIdolsMethodPermission:
        Type: AWS::Lambda::Permission
        Properties:
            FunctionName: !GetAtt getIdolsLambda.Arn
            Action: lambda:InvokeFunction
            Principal: apigateway.amazonaws.com
            SourceArn: !Join
                - ':'
                -   - 'arn:aws:execute-api'
                    - !Ref AWS::Region
                    - !Ref AWS::AccountId
                    - !Join
                        - '/'
                        -   - !Ref apiGateway
                            - '*'
                            - GET
                            - idols
    getIdolsMethod:
        Type: AWS::ApiGateway::Method
        Properties:
            AuthorizationType: NONE
            RestApiId: !Ref apiGateway
            ResourceId: !Ref idolsResource
            HttpMethod: GET
            Integration:
                Type: AWS_PROXY
                IntegrationHttpMethod: POST
                Uri: !Join
                    - ':'
                    -   - arn:aws:apigateway
                        - !Ref AWS::Region
                        - lambda
                        - !Join
                            - /
                            -   - path
                                - '2015-03-31'
                                - functions
                                - !GetAtt getIdolsLambda.Arn
                                - invocations
        DependsOn: getIdolsMethodPermission
```

## Python3でのLambdaの書き方

Python3でLambdaはこのように記述する。

```python
import json
import os

import boto3

def lambda_function(event, context):
    """イベントハンドラです
    """

    # 環境変数はos.environ経由で取得する
    table_name = os.environ['TABLE_NAME']
    # 自分のいるリージョン名はこのように取得する
    region_name = boto3.session.Session().region_name
    # DynamoDBのテーブルを取得するにはこのようにする
    dynamo = boto3.resource('dynamodb', region_name=region_name)
    table = dynamo.Table(table_name) # pylint: disable=no-member
    # 原則としてQueryを使うこと。Scanは遅い
    res = table.query(
        IndexName='GSI',
        KeyConditions={
            'Type': {
                'AttributeValueList': ['Idol'],
                'ComparisonOperator': 'EQ'
            }
        }
    )
    # DynamoDBで取得したアイテムをそのまま返す。必要なら適宜加工すること
    return {
        # HTTPステータスコード。200はOKである
        'statusCode': 200,
        # HTTPのヘッダー
        'headers': {
            # これを書かないとAjaxでCORSエラーになる
            'Access-Control-Allow-Origin': '*'
        },
        # 出力をJSON形式の文字列とする
        'body': json.dumps(res['Items'])
    }
```

これのファイル名をlambda\_function.pyとして保存し、このファイルだけをzipファイルにする。それをS3にアップロードしてCloudFormationのKeyで指定する。
注意点としては、コード更新はCloudFormation経由ではできないため、一度デプロイした関数の更新はCLIを使うなり、マネジメントコンソールを使うなりして行う。